package utils

import (
	"compress/gzip"
	"encoding/json"
	"fmt"
	"io"
	"main/internal/models"
	"net/http"
	"strings"
)

func Decoding(res *http.Response) []byte {

	var body []byte
	var err error
	defer res.Body.Close()

	if res.Header.Get("Content-Encoding") == "gzip" {
		gzipReader, err := gzip.NewReader(res.Body)
		if err != nil {
			fmt.Println("Failed to create gzip reader:", err)
			return nil
		}
		defer gzipReader.Close()
		body, err = io.ReadAll(gzipReader)
		if err != nil {
			fmt.Println("Failed to read gzipped body:", err)
			return nil
		}
	} else {
		body, err = io.ReadAll(res.Body)
		if err != nil {
			fmt.Println("Failed to read response body:", err)
			return nil
		}
	}
	return body
}

// For Future API
func EncodeProfiles(profiles []models.ProfileRes) {
	_, err := json.Marshal(profiles)
	if err != nil {
		return
	}
}

func ExtractProfiles(jsonData []byte) ([]map[string]interface{}, error) {
	var resp models.AutoGenerated
	err := json.Unmarshal(jsonData, &resp)
	if err != nil {
		return nil, err
	}

	var profiles []map[string]interface{}

	for _, item := range resp.Included {
		if strings.Contains(item.EntityUrn, "urn:li:fsd_profile:") {
			profile := make(map[string]interface{})
			profile["entityUrn"] = item.NavigationURL
			fullName := item.Title.Text
			profile["fullName"] = fullName
			profile["bserpEntityNavigationalUrl"] = item.BserpEntityNavigationalURL
			nameParts := strings.Split(fullName, " ")
			if len(nameParts) > 0 {
				profile["lastName"] = nameParts[len(nameParts)-1]
			}

			if item.PrimarySubtitle.Text != "" {
				profile["position"] = item.PrimarySubtitle.Text
			}

			profiles = append(profiles, profile)
		}
	}

	return profiles, nil
}

func ExtractPosts(jsonData []byte) ([]models.PostRes, error) {
    var resp models.Post
    err := json.Unmarshal(jsonData, &resp)
    if err != nil {
        return nil, err
    }

    var posts []models.PostRes
    socialCounts := make(map[string]models.PostRes)

    // First pass: collect social activity counts
    for _, item := range resp.Included {
        if strings.Contains(item.EntityUrn, "fsd_socialActivityCounts") {
            urn := strings.TrimPrefix(item.Urn, "urn:li:activity:")
            socialCounts[urn] = models.PostRes{
                NumLikes:    item.NumLikes,
                NumComments: item.NumComments,
            }
        }
    }

    // Second pass: extract posts and merge with social counts
    for _, item := range resp.Included {
        if strings.Contains(item.EntityUrn, "fsd_update") {
            urn := strings.TrimPrefix(item.EntityUrn, "urn:li:fsd_update:(urn:li:activity:")
            urn = strings.Split(urn, ",")[0]

            post := models.PostRes{
                URN:          item.EntityUrn,
                ActionTarget: item.Content.ArticleComponent.NavigationContext.ActionTarget,
                Name:         item.Actor.Name.Text,
                Text:         item.Commentary.Text.Text,
            }

            if post.Text == "" {
                post.Text = item.Content.ArticleComponent.Title.Text
            }

            if counts, ok := socialCounts[urn]; ok {
                post.NumLikes = counts.NumLikes
                post.NumComments = counts.NumComments
            }
			if post.Text != "" && post.Name != "" {
                posts = append(posts, post)
            }
            posts = append(posts, post)
        }
    }

    return posts, nil
}