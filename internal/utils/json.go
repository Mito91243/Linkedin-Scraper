package utils

import (
	"compress/gzip"
	"encoding/json"
	"fmt"
	"io"
	"main/internal/models"
	"net/http"
	"strings"
)

func Decoding(res *http.Response) []byte {

	var body []byte
	var err error
	defer res.Body.Close()

	if res.Header.Get("Content-Encoding") == "gzip" {
		gzipReader, err := gzip.NewReader(res.Body)
		if err != nil {
			fmt.Println("Failed to create gzip reader:", err)
			return nil
		}
		defer gzipReader.Close()
		body, err = io.ReadAll(gzipReader)
		if err != nil {
			fmt.Println("Failed to read gzipped body:", err)
			return nil
		}
	} else {
		body, err = io.ReadAll(res.Body)
		if err != nil {
			fmt.Println("Failed to read response body:", err)
			return nil
		}
	}
	return body
}

// For Future API
func EncodeProfiles(profiles []models.ProfileRes) {
	_, err := json.Marshal(profiles)
	if err != nil {
		return
	}
}

func ExtractProfiles(jsonData []byte) ([]map[string]interface{}, error) {
	var resp models.AutoGenerated
	err := json.Unmarshal(jsonData, &resp)
	if err != nil {
		return nil, err
	}

	var profiles []map[string]interface{}

	for _, item := range resp.Included {
		if strings.Contains(item.EntityUrn, "urn:li:fsd_profile:") {
			profile := make(map[string]interface{})
			profile["entityUrn"] = item.NavigationURL

			fullName := item.Title.Text
			profile["fullName"] = fullName

			nameParts := strings.Split(fullName, " ")
			if len(nameParts) > 0 {
				profile["lastName"] = nameParts[len(nameParts)-1]
			}

			if item.PrimarySubtitle.Text != "" {
				profile["position"] = item.PrimarySubtitle.Text
			}

			profiles = append(profiles, profile)
		}
	}

	return profiles, nil
}
